import {transformPeriodStringToPeriod, transformPeriodToPeriodString} from "./period";
import {TPeriod} from "../shared";
import {TPeriodString} from "../sql";

describe("transformPeriodStringToPeriod", () => {

    // Transform simple period strings (daily, weekly, biWeekly, monthly) to direct period values
    it("should return direct period value when given a simple period string", () => {
        const periodString = "daily";
        const result = transformPeriodStringToPeriod(periodString);
        expect(result).toBe("daily");
    });

    // Handle invalid period string formats
    it("should parse quantity-unit format correctly", () => {
        const periodString = "2-week";
        const result = transformPeriodStringToPeriod(periodString);
        expect(result).toEqual({
            "quantity": 2,
            "unit": "week"
        });
    });

    // Transform 'every-[day]' strings to recurrence objects with every/dayOfWeek
    it("should return recurrence object with every and dayOfWeek when given an every-[day] string", () => {
        const periodString = "every-monday";
        const result = transformPeriodStringToPeriod(periodString);
        expect(result).toEqual({
            "recurrence": "every",
            "dayOfWeek": "monday"
        });
    });

    // Transform 'everyOther-[day]' strings to recurrence objects with everyOther/dayOfWeek
    it("should return recurrence object with everyOther and correct dayOfWeek when given everyOther-[day] string", () => {
        const periodString = "everyOther-monday";
        const result = transformPeriodStringToPeriod(periodString);
        expect(result).toEqual({
            "recurrence": "everyOther",
            "dayOfWeek": "monday"
        });
    });

    // Transform '[number]-[unit]' strings to quantity/unit objects
    it("should return quantity and unit object when given a number-unit string", () => {
        const periodString = "5-day";
        const result = transformPeriodStringToPeriod(periodString);
        expect(result).toEqual({"quantity": 5,
            "unit": "day"});
    });

    // Handle invalid day of week values in recurrence strings
    it("should throw an error when given an invalid day of week in recurrence string", () => {
        const periodString = "every-invalidDay";
        expect(() => transformPeriodStringToPeriod(periodString)).toThrowError();
    });

    // Handle invalid unit values in quantity strings
    it("should throw an error when given a quantity string with an invalid unit", () => {
        const periodString = "10-year";
        expect(() => transformPeriodStringToPeriod(periodString)).toThrowError();
    });

    // Handle non-numeric quantity values
    it("should throw an error when quantity is non-numeric", () => {
        const periodString = "abc-day";
        expect(() => transformPeriodStringToPeriod(periodString)).toThrow();
    });

    // Handle empty or null period strings
    it("should throw an error when given an empty or null period string", () => {
        const emptyPeriodString = "";
        const nullPeriodString = null;
        expect(() => transformPeriodStringToPeriod(emptyPeriodString)).toThrow();
        expect(() => transformPeriodStringToPeriod(nullPeriodString as unknown as TPeriodString)).toThrow();
    });
});

// Generated by Qodo Gen

describe("transformPeriodToPeriodString", () => {

    // Transform string periods (daily, biWeekly, weekly, monthly) directly to same value
    it("should return same value when period is a string literal", () => {
        const stringPeriods = ["daily", "biWeekly", "weekly", "monthly"] as const;

        stringPeriods.forEach(period => {
            const result = transformPeriodToPeriodString(period);
            expect(result).toBe(period);
        });
    });

    // Pass invalid period object missing required properties
    it("should throw error when period object is missing required properties", () => {
        const invalidPeriod = {} as TPeriod;

        expect(() => transformPeriodToPeriodString(invalidPeriod)).toThrow("Invalid period");
    });

    // Transform quantity-based periods to format 'quantity-unit'
    it("should return formatted string when period has quantity and unit", () => {
        const period = {"quantity": 5,
            "unit": "day"};
        const result = transformPeriodToPeriodString(period as TPeriod);
        expect(result).toBe("5-day");
    });

    // Transform recurrence-based periods to format 'recurrence-dayOfWeek'
    it("should return formatted string when period has recurrence and dayOfWeek", () => {
        const recurrencePeriods = [
            {"recurrence": "every",
                "dayOfWeek": "sunday"},
            {"recurrence": "everyOther",
                "dayOfWeek": "monday"},
            {"recurrence": "every",
                "dayOfWeek": "tuesday"},
            {"recurrence": "everyOther",
                "dayOfWeek": "wednesday"},
            {"recurrence": "every",
                "dayOfWeek": "thursday"},
            {"recurrence": "everyOther",
                "dayOfWeek": "friday"},
            {"recurrence": "every",
                "dayOfWeek": "saturday"}
        ];

        const expectedResults = [
            "every-sunday",
            "everyOther-monday",
            "every-tuesday",
            "everyOther-wednesday",
            "every-thursday",
            "everyOther-friday",
            "every-saturday"
        ];

        recurrencePeriods.forEach((period, index) => {
            const result = transformPeriodToPeriodString(period as TPeriod);
            expect(result).toBe(expectedResults[index]);
        });
    });

    // Handle both 'every' and 'everyOther' recurrence types
    it("should return correct period string for \"every\" and \"everyOther\" recurrence types", () => {
        const recurrencePeriods = [
            {"recurrence": "every",
                "dayOfWeek": "monday"},
            {"recurrence": "everyOther",
                "dayOfWeek": "friday"}
        ];

        const expectedResults = ["every-monday", "everyOther-friday"];

        recurrencePeriods.forEach((period, index) => {
            const result = transformPeriodToPeriodString(period as TPeriod);
            expect(result).toBe(expectedResults[index]);
        });
    });

    // Handle all valid dayOfWeek values (sunday through saturday)
    it("should return correct period string for all valid dayOfWeek values", () => {
        const dayOfWeekPeriods = [
            {"recurrence": "every",
                "dayOfWeek": "sunday"},
            {"recurrence": "every",
                "dayOfWeek": "monday"},
            {"recurrence": "every",
                "dayOfWeek": "tuesday"},
            {"recurrence": "every",
                "dayOfWeek": "wednesday"},
            {"recurrence": "every",
                "dayOfWeek": "thursday"},
            {"recurrence": "every",
                "dayOfWeek": "friday"},
            {"recurrence": "every",
                "dayOfWeek": "saturday"},
            {"recurrence": "everyOther",
                "dayOfWeek": "sunday"},
            {"recurrence": "everyOther",
                "dayOfWeek": "monday"},
            {"recurrence": "everyOther",
                "dayOfWeek": "tuesday"},
            {"recurrence": "everyOther",
                "dayOfWeek": "wednesday"},
            {"recurrence": "everyOther",
                "dayOfWeek": "thursday"},
            {"recurrence": "everyOther",
                "dayOfWeek": "friday"},
            {"recurrence": "everyOther",
                "dayOfWeek": "saturday"}
        ];

        const expectedResults = [
            "every-sunday",
            "every-monday",
            "every-tuesday",
            "every-wednesday",
            "every-thursday",
            "every-friday",
            "every-saturday",
            "everyOther-sunday",
            "everyOther-monday",
            "everyOther-tuesday",
            "everyOther-wednesday",
            "everyOther-thursday",
            "everyOther-friday",
            "everyOther-saturday"
        ];

        dayOfWeekPeriods.forEach((period, index) => {
            const result = transformPeriodToPeriodString(period as TPeriod);
            expect(result).toBe(expectedResults[index]);
        });
    });
});
